library(ggplot2)
library(igraph)
library(shiny)
library(SPARQL)

endpoint <- "http://ws-azane:8080/"

# this method does not work with updateSlectInput()'s label feature
#  whereclause <- includeText('./tickitjoin.rqx')
joining <- "
?eventid <venueid> ?venueid .
?venueid <venuename> ?location .
?eventid <catid> ?catid .
?catid <catname> ?category .
?eventid <dateid> ?dateid .
?dateid <caldate> ?date .
"

# Setup a list for the fetch values
# they can be accessed with the following pattern: fetching$select

fetching = list(
 select="fetch select clause",
 where="fetch where clause",
 order="fetch order clause",
 limit="fetch limit clause"
)
#fetch:
#SELECT ?p ?o
#FROM <tickit>
#WHERE {
#<person2> ?p ?o
#}
#ORDER BY desc(?p) ?o 
# LIMIT 100
     
      
whereclauses <- c(
  "Joining" = joining,
  "Fetching" = fetching$select,
  "test" = list(select="test select clause",where="test where clause") 
  )

defaultLimit <- 50

# Define server logic
shinyServer(function(input, output, session) {

  bootstrap <- function(){
   updateSelectInput(session, "whereclause", label="Select a WHERE clause:", choices = whereclauses, selected = joining)
   updateSliderInput(session, "limit", value = defaultLimit)
  }
  isolate(bootstrap())
 
# depending on what you choose, the query template changes in what clauses there are, and what the user-changeable variabels for those clauses are.
# which means, the UI will need to update depending on which option is chosen

  queryTemplate <-
"SELECT ?eventname ?location ?category ?date
FROM <tickit>
WHERE { ?:whereclause } 
ORDER BY ?date ?eventname ?location ?category LIMIT ?:limit
"

  #Set the query results to a variable and replace the LIMIT value with the slider input
  query <-reactive({ 
                    temp <- 
                            gsub("\\?:whereclause", input$whereclause[1], queryTemplate) 
                            gsub("\\?:limit", input$limit[1], temp) 
                   })
  results <-reactive({SPARQL(endpoint, query())$results})
  ego <-reactive({graph.data.frame(results(), directed=F)})
  
  # I want to set the selected value to a variable so that I can access the list's clauses
  selectedclause <-reactive({input$whereclause[1]})

  output$egoPlot <- renderPlot({
    plot(ego())
  }, width = "auto", height = 400)
  
  output$resultsTable <- renderDataTable({
    results()
  })
  
  output$SPARQLquery <- renderText({
    query()
  })

 output$options <- renderText({
   # "output options: " + selectedclause
   # "output options: " + selectedclause[0]
   # "output options: " + queryTemplate
 })
})
