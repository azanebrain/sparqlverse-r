# libraries
library(ggplot2)
library(igraph)
library(shiny)
library(SPARQL)

# vars
endpoint <- "http://ws-azane:8080/"

# The query templates for each example
queryTemplateSlider <- "SELECT ?eventname LIMIT ?:limit" 
queryTemplateText <- "SELECT ?:eventname WHERE ?:where LIMIT ?limit" 
queryTemplateJoin <- 
  "SELECT ?p ?o
  FROM <tickit>
  WHERE { ?:whereclause }
  ORDER BY desc(?p) ?o 
  LIMIT ?:limit
  "

queryTemplateFetch <-
  "SELECT ?eventname ?location ?category ?date
  FROM <tickit>
  WHERE { 
   ?eventid <venueid> ?venueid .
    ?venueid <venuename> ?location .
    ?eventid <catid> ?catid .
    ?catid <catname> ?category .
    ?eventid <dateid> ?dateid .
    ?dateid <caldate> ?date .
    ?eventid <eventname> ?eventname .
  } 
  ORDER BY ?date ?eventname ?location ?category 
  LIMIT ?:limit
  "

shinyServer(function(input,output) {
  # Does this function need 'session' like in svxtickitjoin ?

  # Modify the query statement depending on each unique interface
  # Each interface has different configurable values that must be modified in 
  # the query that is being sent to SVX
  query <- reactive({
    if (is.null(input$input_type)) {
      return(NULL)
    }
    else if (input$input_type == "Fetching" ) {
        temp <- sub("\\?:limit", input$limit[1], queryTemplateFetch)
    } 
    else if (input$input_type == "Joining" ) {
        temp <- sub("\\?:whereclause", input$whereclause, queryTemplateJoin)
        sub("\\?:limit", input$limit[1], temp)
    } 
    else if (input$input_type == "slider" ) {
        sub("\\?:limit", input$sliderlimit[1], queryTemplateSlider)
    } 
    else if (input$input_type == "text" ) {
        temp <- sub("\\?:where", "the where clause has changed", queryTemplateText)
        sub("\\?:eventname", "the event name has changed", temp)

    }
  })

  results <-reactive({SPARQL(endpoint, query())$results})
  ego <-reactive({graph.data.frame(results(), directed=F)})

  # Demo component:
  output$ui <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Fetching" = plotOutput("egoPlot"),
      "Joining" = plotOutput("egoPlot"),
      # Demo
      "slider" = sliderInput("dynamic", "Dynamic",
        min = 1, max = 20, value = 10),
      "text" = textInput("dynamic", "Dynamic",
        value = "starting value")
    )
  })


  # The limit component
  output$limit <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Fetching" = sliderInput("limit",
        "Set the range:",
        min = 1,
        max = 500,
        step = 1,
        value = 10,
        animate = TRUE
      ),
      "Joining" = sliderInput("limit",
        "Set the range:",
        min = 1,
        max = 100,
        step = 10,
        value = 50
      ),
      "slider" = sliderInput("sliderlimit",
        "Set the range:",
        min = 1,
        max = 500,
        step = 1,
        value = 10,
        animate = TRUE
      )
    )
  })

  # The where clause component
  output$whereclause <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Joining" = textInput("whereclause", "Enter the WHERE clause:", "<person2> ?p ?o")
    )
  })

  # Demo
  output$input_type_text <- renderText({
    input$input_type
  })
     
  # Demo
  output$dynamic_value <- renderPrint({
    str(input$dynamic)
  })

  # Ego Plot
  output$egoPlot <- renderPlot({
    plot(ego())
  }, width="auto", height=400 )

  # Table
  output$resultsTable <- renderDataTable({
    results()
  })

  # The query (in text format) being sent to SVX
  output$SPARQLquery <- renderText({
   query()
  })

})

