# libraries
library(ggplot2)
library(igraph)
library(shiny)
library(SPARQL)

# vars
endpoint <- "http://ws-akeen:8080/"

# The query templates for each example
queryTemplateSlider <- "SELECT ?eventname LIMIT ?:limit" 
queryTemplateText <- "SELECT ?:eventname WHERE ?:where LIMIT ?limit" 
queryTemplateJoin <- 
  "SELECT ?p ?o
  FROM <tickit>
  WHERE { ?:whereclause }
  ORDER BY desc(?p) ?o 
  LIMIT ?:limit
  "

queryTemplateFetch <-
  "SELECT ?eventname ?location ?category ?date
  FROM <tickit>
  WHERE { 
   ?eventid <venueid> ?venueid .
    ?venueid <venuename> ?location .
    ?eventid <catid> ?catid .
    ?catid <catname> ?category .
    ?eventid <dateid> ?dateid .
    ?dateid <caldate> ?date .
    ?eventid <eventname> ?eventname .
  } 
  ORDER BY ?date ?eventname ?location ?category 
  LIMIT ?:limit
  "

queryTemplateCPUUsage<-
  "select 
    ?requestnum( sum(?idle)as?idle ) 
    (sum(?utime)as?user) 
    (sum(?stime)as?sys) 
    (sum(?iowait)as?iowait) 
  where { table 'str_core_recent' } 
  group by ?requestnum 
  order by ?requestnum
  "

shinyServer(function(input,output) {
  # Does this function need 'session' like in svxtickitjoin ?

  # Modify the query statement depending on each unique interface
  # Each interface has different configurable values that must be modified in 
  # the query that is being sent to SVX
  query <- reactive({
    if (is.null(input$input_type)) {
      return(NULL)
    }
    else if (input$input_type == "Fetching" ) {
        temp <- sub("\\?:limit", input$limit[1], queryTemplateFetch)
    } 
    else if (input$input_type == "Joining" ) {
        temp <- sub("\\?:whereclause", input$whereclause, queryTemplateJoin)
        sub("\\?:limit", input$limit[1], temp)
    } 
    else if (input$input_type == "CPU Usage" ) {
        # sub("\\?:limit", input$sliderlimit[1], queryTemplateCPUUsage)
        queryTemplateCPUUsage
    }
    # Demo
    else if (input$input_type == "slider" ) {
        sub("\\?:limit", input$sliderlimit[1], queryTemplateSlider)
    } 
    else if (input$input_type == "text" ) {
        temp <- sub("\\?:where", "the where clause has changed", queryTemplateText)
        sub("\\?:eventname", "the event name has changed", temp)
    }
  })

  results <-reactive({SPARQL(endpoint, query())$results})
  # Ego Graph used for plots
  ego <-reactive({graph.data.frame(results(), directed=F)})

  # CPU Usage Y Axis
  cpuyaxis <- reactive({
    #"user"
   if (is.null(input$input_type)) {
     return(NULL)
   }
   else {
     input$yaxis
   }
  })

  # Demo component:
  output$ui <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Fetching" = plotOutput("egoPlot"),
      "Joining" = plotOutput("egoPlot"),
      "CPU Usage" = plotOutput("cpuUsageLine"),
      # Demo
      "slider" = sliderInput("dynamic", "Dynamic",
        min = 1, max = 20, value = 10),
      "text" = textInput("dynamic", "Dynamic",
        value = "starting value")
    )
  })


  # The limit component
  output$limit <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Fetching" = sliderInput("limit",
        "Set the range:",
        min = 1,
        max = 500,
        step = 1,
        value = 10,
        animate = TRUE
      ),
      "Joining" = sliderInput("limit",
        "Set the range:",
        min = 1,
        max = 100,
        step = 10,
        value = 50
      ),
      "slider" = sliderInput("sliderlimit",
        "Set the range:",
        min = 1,
        max = 500,
        step = 1,
        value = 10,
        animate = TRUE
      )
    )
  })

  # The where clause component
  output$whereclause <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "Joining" = textInput("whereclause", "Enter the WHERE clause:", "<person2> ?p ?o")
    )
  })

  # Y axis
  output$yaxis <- renderUI({
    if (is.null(input$input_type)) {
      return()
    }
    switch(input$input_type,
      "CPU Usage" = selectInput("yaxis",
      "Select the Y Axis:",
      choices = c(
        "user",
        "idle",
        "sys",
        "iowait"
        )
      )
    )
  })

  # Demo
  output$input_type_text <- renderText({
    input$input_type
  })
     
  # Demo
  output$dynamic_value <- renderPrint({
    str(input$dynamic)
  })

  # Ego Plot
  output$egoPlot <- renderPlot({
    plot(ego())
  }, width="auto", height=400 )

  # Line chart
  output$cpuUsageLine <- renderPlot({
     #p <- ggplot(results(), aes(x=requestnum, y=cpuyaxis(), group=1)) +
     #p <- ggplot(results(), aes(x, y)) +
     #p <- ggplot(results()) +
     #p <- ggplot(results(), aes(x=requestnum, y=user, group=1)) +
     p <- ggplot(results()) +
       #geom_point() +
       geom_point( aes(x=requestnum, y=user, group=1) , colour = 'blue') +
       geom_point( aes(x=requestnum, y=sys, group=1) , colour = 'red') +
       geom_point( aes(x=requestnum, y=idle, group=1) , colour = 'yellow') +
       geom_point( aes(x=requestnum, y=iowait, group=1) , colour = 'green') +
       #stat_smooth() +
       xlab("X Label") +
       ylab("Y Label")
       print(p)
  }, width = "auto", height = 400)

  output$cpuUsageLine2 <- renderPlot({
    #qplot(requestnum, user, data=results())
    qplot(requestnum, cpuyaxis(), data=results())
  })
  # Table
  output$resultsTable <- renderDataTable({
    results()
  })

  # The query (in text format) being sent to SVX
  output$SPARQLquery <- renderText({
   query()
  })

})

